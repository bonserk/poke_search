<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>모모를 위한 포켓몬 검색</title>
  <meta name="description" content="PokeAPI 기반 한국어 포켓몬 검색 웹앱" />
  <style>
    :root{
      --bg:#0b1020; --panel:#111831; --muted:#7c8db2; --text:#e6eeff; --accent:#7aa2ff; --accent-2:#4dd4a8; --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0e1430 55%,#0b1020);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Apple Color Emoji,Noto Color Emoji;color:var(--text);}
    .container{max-width:980px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;gap:12px}
    h1{font-size:24px;margin:0}
    .card{background:rgba(255,255,255,0.03);backdrop-filter:saturate(140%) blur(6px);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .searchbar{display:flex;gap:10px;align-items:center}
    input[type="text"]{flex:1;background:#0e1732;color:var(--text);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:14px 16px;font-size:16px;outline:none}
    input[type="text"]:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(122,162,255,.22)}
    button{background:linear-gradient(135deg,var(--accent),#5f85ff);border:none;color:white;padding:12px 16px;border-radius:12px;font-weight:700;cursor:pointer}
    button.secondary{background:#162147;color:var(--text);border:1px solid rgba(255,255,255,.12)}
    .hint{color:var(--muted);font-size:13px;margin-top:8px}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:14px}
    .col-4{grid-column:span 4}
    .col-8{grid-column:span 8}
    .section-title{font-size:14px;letter-spacing:.04em;color:#a9b7dd;margin:0 0 8px 0}
    .kv{display:grid;grid-template-columns:140px 1fr;gap:6px;font-size:15px}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#1a244d;border:1px solid rgba(255,255,255,.12);margin-right:6px;margin-bottom:6px}
    .tag{display:inline-block;padding:6px 10px;border-radius:10px;background:#121a38;border:1px solid rgba(255,255,255,.08);margin:4px;font-size:13px}
    .pill{padding:4px 10px;border-radius:999px;background:#142048;display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,.12)}
    .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .sprite{width:128px;height:128px;image-rendering:pixelated}
    .evo{display:flex;align-items:center;gap:10px;flex-direction:column;align-items:flex-start}
    .arrow{opacity:.6}
    .spinner{width:20px;height:20px;border:3px solid rgba(255,255,255,.2);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{color:var(--danger)}
    .results{margin-top:18px}
    .footer{margin-top:28px;color:var(--muted);font-size:12px;text-align:center}
    .list{max-height:240px;overflow:auto;background:#0c132b;border:1px solid rgba(255,255,255,.1);border-radius:12px}
    .list-item{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.06);cursor:pointer}
    .list-item:hover{background:#10183a}
    @media(max-width:860px){.col-4{grid-column:span 12}.col-8{grid-column:span 12}.kv{grid-template-columns:1fr}}

    /* tables & type badges */
    .table{width:100%;border-collapse:separate;border-spacing:0 6px}
    .table th,.table td{padding:10px 12px;vertical-align:top}
    .table thead th{font-size:13px;color:#a9b7dd;text-align:left}
    .row{background:#0c132b;border:1px solid rgba(255,255,255,.08);border-radius:10px}
    .row td:first-child{border-top-left-radius:10px;border-bottom-left-radius:10px}
    .row td:last-child{border-top-right-radius:10px;border-bottom-right-radius:10px}
    .badge-type{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);margin:3px;font-size:13px;line-height:1}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 22C17.523 22 22 17.523 22 12S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Zm0-1.8a8.2 8.2 0 1 0 0-16.4 8.2 8.2 0 0 0 0 16.4Zm-8-8.2h7v-6.7A6.7 6.7 0 0 0 4 12ZM12 6.3V12h6.7A6.7 6.7 0 0 0 12 6.3Z" fill="currentColor"/></svg>
      <h1>모모를 위한 포켓몬 검색</h1>
      <div class="pill"><span>데이터</span><strong>PokeAPI</strong></div>
    </header>

    <div class="card" style="margin-top:14px">
      <div class="searchbar">
        <input id="query" type="text" placeholder="예: 피카츄, 파이리, 이상해씨, 꼬부기… (영문/번호도 가능)" />
        <button id="searchBtn">검색</button>
        <button id="warmBtn" class="secondary" title="한국어 이름 인덱스를 순차적으로 구축합니다.">KO 인덱스 구축</button>
      </div>
      <div class="hint">입력은 한국어/영문 이름 또는 전국도감 번호(예: 25). 한국어 이름 즉시 검색이 안 되면 ‘KO 인덱스 구축’을 눌러 로컬에 점진적으로 이름 매핑을 만듭니다(요청 속도 제한 준수).</div>
      <div id="status" class="hint"></div>
      <div id="suggest" class="list" style="display:none"></div>
    </div>

    <div id="result" class="results"></div>

    <div class="footer">ⓘ 모모아빠 만듬. 데이터 출처: PokeAPI. 이미지: PokeAPI sprites.</div>
  </div>

<script>
/**
 * PokeSearch-KR (업데이트 반영)
 * - 한국어/영문/번호 검색
 * - 기본 정보, 진화(조건/필요 레벨), 기술(레벨업 위주, 한/영 병기)
 * - 속성 상성: 방어 기준 테이블 + 공격 기준(내 타입별) 테이블
 * - 한국어 이름 매핑: localStorage 기반 점진 인덱싱
 * - 타입 라벨(한글) & 컬러 커스텀
 */

const API = 'https://pokeapi.co/api/v2';
const $ = (sel) => document.querySelector(sel);
const resultEl = $('#result');
const statusEl = $('#status');
const suggestEl = $('#suggest');
const queryEl = $('#query');

// ---------- Local cache ----------
const db = {
  get koMap(){ try{return JSON.parse(localStorage.getItem('koMap')||'{}')}catch{return {}} },
  set koMap(v){ localStorage.setItem('koMap', JSON.stringify(v)); },
  get speciesList(){ try{return JSON.parse(localStorage.getItem('speciesList')||'[]')}catch{return []} },
  set speciesList(v){ localStorage.setItem('speciesList', JSON.stringify(v)); },
  get lastIndexed(){ return parseInt(localStorage.getItem('lastIndexed')||'0',10); },
  set lastIndexed(v){ localStorage.setItem('lastIndexed', String(v)); },
};

// Prefetch species list
async function ensureSpeciesList(){
  if(db.speciesList.length>0) return db.speciesList;
  const res = await fetch(`${API}/pokemon-species?limit=20000`);
  if(!res.ok) throw new Error('species list fetch 실패');
  const data = await res.json();
  const list = data.results.map(x=>({name:x.name, url:x.url, id: parseInt(x.url.match(/\/(\d+)\/?$/)[1],10)}));
  db.speciesList = list;
  return list;
}

// KO index builder
let indexerRunning = false;
async function buildKoIndex(batchSize=15, delayMs=1500){
  if(indexerRunning) return;
  indexerRunning = true;
  const list = await ensureSpeciesList();
  let i = db.lastIndexed || 0;
  let processed = 0;
  while(i < list.length && processed < batchSize){
    const sp = list[i];
    try{
      const sres = await fetch(sp.url);
      if(!sres.ok) throw new Error('species fetch 실패');
      const s = await sres.json();
      const koName = (s.names||[]).find(n=>n.language?.name==='ko')?.name;
      if(koName){
        const map = db.koMap; map[koName.trim()] = { id:s.id, en:s.name }; db.koMap = map;
      }
    }catch(e){ console.warn('index err', e); }
    i++; processed++;
    db.lastIndexed = i;
    statusEl.textContent = `KO 인덱싱 진행: ${i}/${list.length} (브라우저에 저장됨)`;
    await sleep(delayMs);
  }
  indexerRunning = false;
}

$('#warmBtn').addEventListener('click', ()=>{
  (async()=>{
    await ensureSpeciesList();
    let loops = 8;
    async function step(){ if(loops--<=0) return; await buildKoIndex(15, 1100); setTimeout(step, 200); }
    step();
  })();
});

// Suggest list
queryEl.addEventListener('input', ()=>{
  const q = queryEl.value.trim();
  if(!q){ suggestEl.style.display='none'; return; }
  const map = db.koMap;
  const keys = Object.keys(map).filter(k=>k.includes(q)).slice(0,50);
  if(keys.length){
    suggestEl.innerHTML = keys.map(k=>`<div class="list-item" data-id="${map[k].id}">${k} <span class="hint">#${map[k].id}</span></div>`).join('');
    suggestEl.style.display='block';
    suggestEl.querySelectorAll('.list-item').forEach(li=>li.addEventListener('click', e=>{
      const id = e.currentTarget.getAttribute('data-id');
      queryEl.value = Object.entries(map).find(([name,v])=>String(v.id)===String(id))[0];
      suggestEl.style.display='none';
      search();
    }));
  } else {
    suggestEl.style.display='none';
  }
});

$('#searchBtn').addEventListener('click', search);
queryEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter') search(); });

async function search(){
  const q = queryEl.value.trim();
  if(!q) return;
  resultEl.innerHTML = skeleton();
  statusEl.textContent = '';

  try{
    const resolved = await resolveQuery(q);
    if(!resolved) throw new Error('해당 이름/번호를 찾을 수 없습니다. KO 인덱스를 구축 후 다시 시도하세요.');
    const { id, en, ko } = resolved;

    const [pokemon, species] = await Promise.all([
      fetchJson(`${API}/pokemon/${id}`),
      fetchJson(`${API}/pokemon-species/${id}`),
    ]);

    const evo = await loadEvolution(species);
    const moves = await loadMovesKR(pokemon);

    await renderPokemon({ pokemon, species, evo, moves, koName:ko, enName:en });
  }catch(err){
    console.error(err);
    resultEl.innerHTML = `<div class="card error">오류: ${escapeHtml(err.message||String(err))}</div>`;
  }
}

// Resolve user query
async function resolveQuery(q){
  if(/^\d+$/.test(q)){
    const id = parseInt(q,10); return { id, en: null, ko: Object.entries(db.koMap).find(([k,v])=>v.id===id)?.[0]||null };
  }
  try{
    const p = await fetchJson(`${API}/pokemon/${encodeURIComponent(q.toLowerCase())}`);
    return { id:p.id, en:p.name, ko: Object.entries(db.koMap).find(([k,v])=>v.id===p.id)?.[0]||null };
  }catch{}
  const hit = db.koMap[q];
  if(hit) return { id: hit.id, en: hit.en, ko: q };

  const list = await ensureSpeciesList();
  const windowSize = 60;
  const start = Math.max(0, db.lastIndexed - windowSize);
  const end = Math.min(list.length, db.lastIndexed + windowSize);
  for(let i=start;i<end;i++){
    const s = await fetchJson(list[i].url);
    const koName = (s.names||[]).find(n=>n.language?.name==='ko')?.name?.trim();
    if(koName){ const map = db.koMap; map[koName] = { id:s.id, en:s.name }; db.koMap = map; }
    if(koName===q){ return { id:s.id, en:s.name, ko:q } }
    await sleep(180);
  }
  return null;
}

async function fetchJson(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error(`요청 실패: ${url}`);
  return res.json();
}

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

function statRows(stats){
  return stats.map(s=>`<div class="kv"><div>${s.stat.name.toUpperCase()}</div><div><div class="badge">${s.base_stat}</div></div></div>`).join('');
}

function abilities(abilities){
  return abilities.map(a=>`<span class="badge">${a.ability.name}${a.is_hidden? ' (hidden)': ''}</span>`).join('');
}

/* ---------- 진화: edges + 조건(details) ---------- */
async function loadEvolution(species){
  if(!species?.evolution_chain?.url) return [];
  const chain = await fetchJson(species.evolution_chain.url);
  const edges = [];
  const map = db.koMap;

  function nodeInfo(sp){
    const id = parseInt(sp.url.match(/\/(\d+)\/?$/)[1], 10);
    const en = sp.name;
    const ko = Object.keys(map).find(k => map[k].en === en) || null;
    return { id, en, ko, name: en };
  }

  function walk(node){
    if(!node) return;
    const from = nodeInfo(node.species);
    (node.evolves_to || []).forEach(child => {
      const to = nodeInfo(child.species);
      const details = child.evolution_details || [];
      edges.push({ from, to, details });
      walk(child);
    });
  }

  walk(chain.chain);
  return edges;
}

/** 조건 문자열화: 레벨업은 "(필요: Lv N)"로 명확히 표시 */
function formatEvoDetails(details){
  if(!details || !details.length) return '조건 정보 없음';
  const fmtOne = (d)=>{
    const P=[];
    if(d.trigger?.name){
      const t = d.trigger.name;
      const base = t==='level-up'?'레벨업'
                 : t==='use-item'?'아이템 사용'
                 : t==='trade'    ?'교환'
                 : t==='shed'     ?'갈라짐'
                 : t==='spin'     ?'회전'
                 : t;
      if(t==='level-up' && d.min_level){
        P.push(`${base} (필요: Lv ${d.min_level})`);
      } else {
        P.push(base);
      }
    }
    // min_level은 위에서 처리(레벨업일 때만 의미있음). 그 외 조건들은 그대로 병기
    if(d.item?.name) P.push(`item:${d.item.name}`);
    if(d.held_item?.name) P.push(`held:${d.held_item.name}`);
    if(d.time_of_day) P.push(`${d.time_of_day} 시간대`);
    if(d.min_happiness) P.push(`친밀도≥${d.min_happiness}`);
    if(d.min_beauty) P.push(`뷰티≥${d.min_beauty}`);
    if(d.min_affection) P.push(`애정도≥${d.min_affection}`);
    if(d.known_move?.name) P.push(`기술:${d.known_move.name}`);
    if(d.known_move_type?.name) P.push(`타입:${d.known_move_type.name}`);
    if(d.location?.name) P.push(`장소:${d.location.name}`);
    if(d.needs_overworld_rain) P.push('비 오는 날');
    if(d.turn_upside_down) P.push('기기 거꾸로');
    if(Number.isInteger(d.gender)) P.push(d.gender===1?'♀ 전용':'♂ 전용');
    if(d.relative_physical_stats===1)  P.push('공격>방어');
    if(d.relative_physical_stats===-1) P.push('공격<방어');
    if(d.relative_physical_stats===0)  P.push('공격=방어');
    if(d.party_type?.name) P.push(`파티 타입:${d.party_type.name}`);
    if(d.party_species?.name) P.push(`파티 종:${d.party_species.name}`);
    return P.join(' · ') || '조건 정보 없음';
  };
  return details.map(fmtOne).join(' OR ');
}

/* ---------- 기술(레벨업, 최신 버전그룹) ---------- */
async function loadMovesKR(pokemon){
  const groups = new Set();
  pokemon.moves.forEach(m=>m.version_group_details.forEach(v=>groups.add(v.version_group.name)));
  const latest = Array.from(groups).sort().slice(-1)[0];
  const byLevel = pokemon.moves
    .map(m=>({
      name: m.move.name,
      url: m.move.url,
      lv: (m.version_group_details.find(v=>v.version_group.name===latest && v.move_learn_method.name==='level-up')||{}).level_learned_at||null
    }))
    .filter(x=>x.lv!==null)
    .sort((a,b)=>a.lv-b.lv)
    .slice(0,40);

  const out=[];
  for(const mv of byLevel){
    try{
      const j = await fetchJson(mv.url);
      const ko = (j.names||[]).find(n=>n.language?.name==='ko')?.name || mv.name;
      out.push({ level: mv.lv, en: mv.name, ko });
      await sleep(80);
    }catch{ out.push({ level: mv.lv, en: mv.name, ko: mv.name }); }
  }
  return out;
}

/* ---------- 타입 상성(라벨/컬러/표/공격·방어) ---------- */
const TYPE_KEYS = ['normal','fire','water','electric','grass','ice','fighting','poison','ground','flying','psychic','bug','rock','ghost','dragon','dark','steel','fairy'];

async function ensureTypeChart(){
  try{
    const cached = JSON.parse(localStorage.getItem('typeChartV2')||'null');
    if(cached) return cached;
  }catch{}
  const entries = await Promise.all(TYPE_KEYS.map(async t=>{
    const j = await fetchJson(`${API}/type/${t}`);
    const rel = j.damage_relations;
    const toNames = (arr)=> (arr||[]).map(x=>x.name);
    return [t, {
      doubleFrom: toNames(rel.double_damage_from),
      halfFrom:   toNames(rel.half_damage_from),
      noFrom:     toNames(rel.no_damage_from),
      doubleTo:   toNames(rel.double_damage_to),
      halfTo:     toNames(rel.half_damage_to),
      noTo:       toNames(rel.no_damage_to)
    }];
  }));
  const chart = Object.fromEntries(entries);
  localStorage.setItem('typeChartV2', JSON.stringify(chart));
  return chart;
}

function computeDefenseMultipliers(defTypes, chart){
  const mult = Object.fromEntries(TYPE_KEYS.map(k=>[k,1]));
  for(const d of defTypes){
    const rel = chart[d]; if(!rel) continue;
    for(const atk of rel.doubleFrom) mult[atk] *= 2;
    for(const atk of rel.halfFrom)   mult[atk] *= 0.5;
    for(const atk of rel.noFrom)     mult[atk] = 0;
  }
  for(const k of Object.keys(mult)){
    mult[k] = (mult[k]===0.25||mult[k]===0.5||mult[k]===1||mult[k]===2||mult[k]===4)? mult[k] : Number(mult[k].toFixed(2));
  }
  return mult;
}

const TYPE_LABEL_KO = {normal:'노말', fire:'불꽃', water:'물', electric:'전기', grass:'풀', ice:'얼음', fighting:'격투', poison:'독', ground:'땅', flying:'비행', psychic:'에스퍼', bug:'벌레', rock:'바위', ghost:'고스트', dragon:'드래곤', dark:'악', steel:'강철', fairy:'페어리'};
const TYPE_COLORS   = {normal:'#A8A77A', fire:'#EE8130', water:'#6390F0', electric:'#F7D02C', grass:'#7AC74C', ice:'#96D9D6', fighting:'#C22E28', poison:'#A33EA1', ground:'#E2BF65', flying:'#A98FF3', psychic:'#F95587', bug:'#A6B91A', rock:'#B6A136', ghost:'#735797', dragon:'#6F35FC', dark:'#705746', steel:'#B7B7CE', fairy:'#D685AD'};

function typeBadge(t){
  const label = TYPE_LABEL_KO[t]||t;
  const color = TYPE_COLORS[t]||'#1a244d';
  return `<span class="badge-type" style="background:${color}22;border-color:${color}66">${label}</span>`;
}

function buildDefenseTable(defense){
  const groups = { '4':[], '2':[], '1':[], '0.5':[], '0.25':[], '0':[] };
  for(const [atk, mul] of Object.entries(defense)) groups[String(mul)].push(atk);
  const order = ['4','2','1','0.5','0.25','0'];
  const row = (mul, arr)=>{
    const cells = arr.sort((a,b)=> (TYPE_LABEL_KO[a]||a).localeCompare(TYPE_LABEL_KO[b]||b)).map(typeBadge).join('') || '<span class="hint">없음</span>';
    return `<tr class="row"><td style="width:120px">×${mul}</td><td>${cells}</td></tr>`;
  };
  return `<table class="table"><thead><tr><th>배율</th><th>공격 타입</th></tr></thead><tbody>`+
         order.map(m=>row(m, groups[m])).join('')+
         `</tbody></table>`;
}

function buildAttackTableFor(atkType, chart){
  const rel = chart[atkType]||{doubleTo:[],halfTo:[],noTo:[]};
  const set2 = new Set(rel.doubleTo), set05 = new Set(rel.halfTo), set0 = new Set(rel.noTo);
  const x1 = TYPE_KEYS.filter(t=>!set2.has(t)&&!set05.has(t)&&!set0.has(t));
  const groups = { '2': Array.from(set2), '1': x1, '0.5': Array.from(set05), '0': Array.from(set0) };
  const order = ['2','1','0.5','0'];
  const row = (mul, arr)=>{
    const cells = arr.sort((a,b)=> (TYPE_LABEL_KO[a]||a).localeCompare(TYPE_LABEL_KO[b]||b)).map(typeBadge).join('') || '<span class="hint">없음</span>';
    return `<tr class="row"><td style="width:120px">×${mul}</td><td>${cells}</td></tr>`;
  };
  return `<table class="table"><thead><tr><th>배율</th><th>상대 타입</th></tr></thead><tbody>`+
         order.map(m=>row(m, groups[m])).join('')+
         `</tbody></table>`;
}

function attackCardsFor(types, chart){
  return types.map(t=>{
    const label = TYPE_LABEL_KO[t.type.name]||t.type.name;
    return `<div class="card" style="margin-top:14px">
        <div class="section-title">공격 상성 — 내 타입: ${label}</div>
        ${buildAttackTableFor(t.type.name, chart)}
      </div>`;
  }).join('');
}

function computeDefenseSection(pokemon, chart){
  const defense = computeDefenseMultipliers(pokemon.types.map(t=>t.type.name), chart);
  return `<div class="card" style="margin-top:14px">
      <div class="section-title">속성 상성 (방어 기준)</div>
      ${buildDefenseTable(defense)}
      <div class="hint">설명: 공격 타입 대비 피해 배율입니다. 예: "불 ×2"는 불꽃 타입 공격에 2배 피해를 받는다는 뜻입니다.</div>
    </div>`;
}

function computeAttackSection(pokemon, chart){
  return attackCardsFor(pokemon.types, chart);
}

function computeTypeSections(pokemon, chart){
  return computeDefenseSection(pokemon, chart) + computeAttackSection(pokemon, chart);
}

/* ---------- 렌더링 ---------- */
async function renderPokemon({ pokemon, species, evo, moves, koName, enName }){
  const displayName = koName || (species.names||[]).find(n=>n.language?.name==='ko')?.name || enName || species.name;
  const id = pokemon.id;
  const sprite = pokemon.sprites?.other?.['official-artwork']?.front_default || pokemon.sprites?.front_default;
  const typesHtml = pokemon.types.map(t=>typeBadge(t.type.name)).join('');

  const moveList = moves.map(m=>`<div class="kv"><div>Lv.${m.level}</div><div>${escapeHtml(m.ko)} <span class="hint">(${escapeHtml(m.en)})</span></div></div>`).join('');

  const chart = await ensureTypeChart();
  const typeSections = computeTypeSections(pokemon, chart);

  // ---- 진화 표시 HTML (edges/stages 모두 대응) ----
  let evoHtml = '<span class="hint">진화 정보 없음</span>';
  if (Array.isArray(evo) && evo.length) {
    if (evo[0] && typeof evo[0] === 'object' && 'from' in evo[0] && 'to' in evo[0]) {
      evoHtml = evo.map(e => {
        const fromNm = e.from.ko || e.from.en;
        const toNm = e.to.ko || e.to.en;
        const cond = formatEvoDetails(e.details);
        return `<div class="flex">
          <div class="pill"><span>#${e.from.id}</span><strong>${escapeHtml(fromNm)}</strong></div>
          <span class="arrow">— ${escapeHtml(cond)} →</span>
          <div class="pill"><span>#${e.to.id}</span><strong>${escapeHtml(toNm)}</strong></div>
        </div>`;
      }).join('');
    } else if (evo[0] && 'id' in evo[0]) {
      evoHtml = evo.map((s, i) => {
        const nm = s.ko || s.name;
        const mid = `<div class="pill"><span>#${s.id}</span><strong>${escapeHtml(nm)}</strong></div>`;
        return mid + (i < evo.length - 1 ? '<span class="arrow">→</span>' : '');
      }).join('');
    }
  }

  resultEl.innerHTML = `
    <div class="card">
      <div class="grid">
        <div class="col-4" style="text-align:center">
          ${sprite? `<img src="${sprite}" alt="${escapeHtml(displayName)}" class="sprite"/>` : ''}
          <div style="margin-top:8px" class="flex">
            <span class="pill">#${id}</span>
            ${typesHtml}
          </div>
        </div>
        <div class="col-8">
          <h2 style="margin:0 0 8px 0">${escapeHtml(displayName)} <span class="hint">(${escapeHtml(species.name)})</span></h2>
          <div class="grid" style="gap:8px">
            <div class="col-8">
              <div class="section-title">기본 정보</div>
              <div class="kv">
                <div>키/몸무게</div><div>${(pokemon.height/10).toFixed(1)} m / ${(pokemon.weight/10).toFixed(1)} kg</div>
                <div>능력(Abilities)</div><div>${abilities(pokemon.abilities)}</div>
                <div>기본 능력치</div><div>${statRows(pokemon.stats)}</div>
              </div>
            </div>
            <div class="col-4">
              <div class="section-title">알 정보</div>
              <div class="kv">
                <div>포획율</div><div>${species.capture_rate}</div>
                <div>기본친밀도</div><div>${species.base_happiness}</div>
                <div>성비</div><div>${genderRatio(species.gender_rate)}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    ${typeSections}

    <div class="card" style="margin-top:14px">
      <div class="section-title">진화 체인</div>
      <div class="evo">${evoHtml}</div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="section-title">레벨업 기술 (최신 버전 그룹 기준 최대 40개)</div>
      ${moveList || '<span class="hint">표시할 기술이 없습니다.</span>'}
    </div>
  `;
}

function genderRatio(g){
  if(g===-1) return '무성';
  const female = (g/8)*100; const male = 100-female; return `♂ ${male.toFixed(0)}% / ♀ ${female.toFixed(0)}%`;
}

function skeleton(){
  return `<div class="card"><div class="flex"><div class="spinner"></div><div>조회 중… PokeAPI에서 데이터를 불러오고 있습니다.</div></div></div>`
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

// First-run: preload species list quickly
ensureSpeciesList().catch(e=>console.warn(e));
</script>
</body>
</html>
