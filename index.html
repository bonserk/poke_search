<script>
/**
 * PokeSearch-KR — 안정화 통합본
 * - 한국어/영문/번호 검색
 * - 기본 정보, 진화(조건/필요 레벨), 기술(레벨업), 속성 상성(방어/공격)
 * - 폼/모습(지역/메가/거다이맥스) 카드
 * - 시작 히어로 이미지: 첫 검색 시 숨김
 */

const API = 'https://pokeapi.co/api/v2';
const $ = (sel) => document.querySelector(sel);
const resultEl = $('#result');
const statusEl = $('#status');
const suggestEl = $('#suggest');
const queryEl = $('#query');

// ---------- Global error guard ----------
window.addEventListener('error', (e)=>{
  console.error('GlobalError:', e.error||e.message);
});

// ---------- Local cache ----------
const db = {
  get koMap(){ try{return JSON.parse(localStorage.getItem('koMap')||'{}')}catch{return {}} },
  set koMap(v){ localStorage.setItem('koMap', JSON.stringify(v)); },
  get speciesList(){ try{return JSON.parse(localStorage.getItem('speciesList')||'[]')}catch{return []} },
  set speciesList(v){ localStorage.setItem('speciesList', JSON.stringify(v)); },
  get lastIndexed(){ return parseInt(localStorage.getItem('lastIndexed')||'0',10); },
  set lastIndexed(v){ localStorage.setItem('lastIndexed', String(v)); },
};

// Prefetch species list
async function ensureSpeciesList(){
  if(db.speciesList.length>0) return db.speciesList;
  const res = await fetch(`${API}/pokemon-species?limit=20000`);
  if(!res.ok) throw new Error('species list fetch 실패');
  const data = await res.json();
  const list = data.results.map(x=>({name:x.name, url:x.url, id: parseInt(x.url.match(/\/(\d+)\/?$/)[1],10)}));
  db.speciesList = list; return list;
}

// KO index builder (opt-in)
let indexerRunning = false;
async function buildKoIndex(batchSize=15, delayMs=1500){
  if(indexerRunning) return; indexerRunning = true;
  const list = await ensureSpeciesList();
  let i = db.lastIndexed || 0; let processed=0;
  while(i<list.length && processed<batchSize){
    const sp = list[i];
    try{
      const s = await fetchJson(sp.url);
      const koName = (s.names||[]).find(n=>n.language?.name==='ko')?.name;
      if(koName){ const map=db.koMap; map[koName.trim()]={id:s.id,en:s.name}; db.koMap=map; }
    }catch(e){ console.warn('index err', e); }
    i++; processed++; db.lastIndexed=i; statusEl.textContent=`KO 인덱싱 진행: ${i}/${list.length}`;
    await sleep(delayMs);
  }
  indexerRunning=false;
}
$('#warmBtn')?.addEventListener('click', ()=>{
  (async()=>{ await ensureSpeciesList(); let loops=8; async function step(){ if(loops--<=0) return; await buildKoIndex(15,1100); setTimeout(step,200);} step(); })();
});

// Suggest list
queryEl?.addEventListener('input', ()=>{
  const q=queryEl.value.trim(); if(!q){suggestEl.style.display='none';return;}
  const map=db.koMap; const keys=Object.keys(map).filter(k=>k.includes(q)).slice(0,50);
  if(keys.length){
    suggestEl.innerHTML = keys.map(k=>`<div class="list-item" data-id="${map[k].id}">${k} <span class="hint">#${map[k].id}</span></div>`).join('');
    suggestEl.style.display='block';
    suggestEl.querySelectorAll('.list-item').forEach(li=>li.addEventListener('click',(e)=>{
      const id=e.currentTarget.getAttribute('data-id');
      queryEl.value = Object.entries(map).find(([n,v])=>String(v.id)===String(id))?.[0]||queryEl.value;
      suggestEl.style.display='none'; search();
    }));
  }else suggestEl.style.display='none';
});

$('#searchBtn')?.addEventListener('click', search);
queryEl?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') search(); });

async function search(){
  const q=queryEl.value.trim(); if(!q) return;
  resultEl.innerHTML = skeleton(); statusEl.textContent='';
  try{
    const resolved = await resolveQuery(q);
    if(!resolved) throw new Error('해당 이름/번호를 찾을 수 없습니다. KO 인덱스를 구축 후 다시 시도하세요.');
    const { id, en, ko } = resolved;
    const [pokemon, species] = await Promise.all([
      fetchJson(`${API}/pokemon/${id}`),
      fetchJson(`${API}/pokemon-species/${id}`)
    ]);
    const [evo, moves, forms] = await Promise.all([
      loadEvolution(species),
      loadMovesKR(pokemon),
      loadForms(species, (ko || (species.names||[]).find(n=>n.language?.name==='ko')?.name || en || species.name))
    ]);
    const hero=$('#hero'); if(hero) hero.style.display='none';
    await renderPokemon({ pokemon, species, evo, moves, koName:ko, enName:en, forms });
  }catch(err){
    console.error(err);
    resultEl.innerHTML = `<div class="card error">오류: ${escapeHtml(err.message||String(err))}</div>`;
  }
}

async function resolveQuery(q){
  if(/^[0-9]+$/.test(q)){
    const id=parseInt(q,10); return { id, en:null, ko:Object.entries(db.koMap).find(([k,v])=>v.id===id)?.[0]||null };
  }
  try{ const p=await fetchJson(`${API}/pokemon/${encodeURIComponent(q.toLowerCase())}`); return { id:p.id,en:p.name,ko:Object.entries(db.koMap).find(([k,v])=>v.id===p.id)?.[0]||null }; }catch{}
  const hit=db.koMap[q]; if(hit) return { id:hit.id, en:hit.en, ko:q };
  const list=await ensureSpeciesList(); const W=60; const s=Math.max(0, db.lastIndexed-W); const e=Math.min(list.length, db.lastIndexed+W);
  for(let i=s;i<e;i++){
    const spec=await fetchJson(list[i].url);
    const ko=(spec.names||[]).find(n=>n.language?.name==='ko')?.name?.trim();
    if(ko){ const map=db.koMap; map[ko]={id:spec.id,en:spec.name}; db.koMap=map; }
    if(ko===q) return { id:spec.id, en:spec.name, ko:q };
    await sleep(180);
  }
  return null;
}

async function fetchJson(url){ const res=await fetch(url); if(!res.ok) throw new Error(`요청 실패: ${url}`); return res.json(); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

function statRows(stats){ return stats.map(s=>`<div class="kv"><div>${s.stat.name.toUpperCase()}</div><div><div class="badge">${s.base_stat}</div></div></div>`).join(''); }
function abilities(abilities){ return abilities.map(a=>`<span class="badge">${a.ability.name}${a.is_hidden?' (히든)':''}</span>`).join(''); }

/* ---------- 진화: edges + 조건(details) ---------- */
async function loadEvolution(species){
  if(!species?.evolution_chain?.url) return [];
  const chain = await fetchJson(species.evolution_chain.url);
  const edges=[]; const map=db.koMap;
  function nodeInfo(sp){ const id=parseInt(sp.url.match(/\/(\d+)\/?$/)[1],10); const en=sp.name; const ko=Object.keys(map).find(k=>map[k].en===en)||null; return {id,en,ko,name:en}; }
  function walk(node){ if(!node) return; const from=nodeInfo(node.species); (node.evolves_to||[]).forEach(child=>{ const to=nodeInfo(child.species); const details=child.evolution_details||[]; edges.push({from,to,details}); walk(child); }); }
  walk(chain.chain); return edges; // edges with details
}

function formatEvoDetails(details){
  if(!details||!details.length) return '조건 정보 없음';
  const fmtOne=(d)=>{
    const P=[];
    if(d.trigger?.name){
      const t=d.trigger.name;
      const base=t==='level-up'?'레벨업': t==='use-item'?'아이템 사용': t==='trade'?'교환': t==='shed'?'갈라짐': t==='spin'?'회전': t;
      if(t==='level-up' && d.min_level){
        P.push(`${base} (필요: Lv ${d.min_level})`);
      } else {
        P.push(base);
      }
    }
    if(d.item?.name) P.push(`아이템:${d.item.name}`);
    if(d.held_item?.name) P.push(`지닌도구:${d.held_item.name}`);
    if(d.time_of_day) P.push(`${d.time_of_day} 시간대`);
    if(d.min_happiness) P.push(`친밀도≥${d.min_happiness}`);
    if(d.min_beauty) P.push(`뷰티≥${d.min_beauty}`);
    if(d.min_affection) P.push(`애정도≥${d.min_affection}`);
    if(d.known_move?.name) P.push(`기술:${d.known_move.name}`);
    if(d.known_move_type?.name) P.push(`타입:${d.known_move_type.name}`);
    if(d.location?.name) P.push(`장소:${d.location.name}`);
    if(d.needs_overworld_rain) P.push('비 오는 날');
    if(d.turn_upside_down) P.push('기기 거꾸로');
    if(Number.isInteger(d.gender)) P.push(d.gender===1?'♀ 전용':'♂ 전용');
    if(d.relative_physical_stats===1) P.push('공격>방어');
    if(d.relative_physical_stats===-1) P.push('공격<방어');
    if(d.relative_physical_stats===0) P.push('공격=방어');
    if(d.party_type?.name) P.push(`같은 타입 동료:${d.party_type.name}`);
    if(d.party_species?.name) P.push(`같은 종 동료:${d.party_species.name}`);
    return P.join(' · ')||'조건 정보 없음';
  };
  return details.map(fmtOne).join(' OR ');
}

/* ---------- 기술(레벨업, 최신 버전그룹) ---------- */
async function loadMovesKR(pokemon){
  const groups=new Set(); pokemon.moves.forEach(m=>m.version_group_details.forEach(v=>groups.add(v.version_group.name)));
  const latest=Array.from(groups).sort().slice(-1)[0];
  const byLevel=pokemon.moves.map(m=>({ name:m.move.name, url:m.move.url, lv:(m.version_group_details.find(v=>v.version_group.name===latest && v.move_learn_method.name==='level-up')||{}).level_learned_at||null }))
    .filter(x=>x.lv!==null).sort((a,b)=>a.lv-b.lv).slice(0,40);
  const out=[]; for(const mv of byLevel){ try{ const j=await fetchJson(mv.url); const ko=(j.names||[]).find(n=>n.language?.name==='ko')?.name||mv.name; out.push({level:mv.lv,en:mv.name,ko}); await sleep(80);}catch{ out.push({level:mv.lv,en:mv.name,ko:mv.name}); } }
  return out;
}

/* ---------- 타입 상성(라벨/컬러/표/공격·방어) ---------- */
const TYPE_KEYS=['normal','fire','water','electric','grass','ice','fighting','poison','ground','flying','psychic','bug','rock','ghost','dragon','dark','steel','fairy'];
const TYPE_LABEL_KO={normal:'노말', fire:'불꽃', water:'물', electric:'전기', grass:'풀', ice:'얼음', fighting:'격투', poison:'독', ground:'땅', flying:'비행', psychic:'에스퍼', bug:'벌레', rock:'바위', ghost:'고스트', dragon:'드래곤', dark:'악', steel:'강철', fairy:'페어리'};
const TYPE_COLORS={normal:'#A8A77A', fire:'#EE8130', water:'#6390F0', electric:'#F7D02C', grass:'#7AC74C', ice:'#96D9D6', fighting:'#C22E28', poison:'#A33EA1', ground:'#E2BF65', flying:'#A98FF3', psychic:'#F95587', bug:'#A6B91A', rock:'#B6A136', ghost:'#735797', dragon:'#6F35FC', dark:'#705746', steel:'#B7B7CE', fairy:'#D685AD'};

async function ensureTypeChart(){
  try{ const cached=JSON.parse(localStorage.getItem('typeChartV2')||'null'); if(cached) return cached; }catch{}
  const entries=await Promise.all(TYPE_KEYS.map(async t=>{ const j=await fetchJson(`${API}/type/${t}`); const rel=j.damage_relations; const toNames=(a)=> (a||[]).map(x=>x.name); return [t,{ doubleFrom:toNames(rel.double_damage_from), halfFrom:toNames(rel.half_damage_from), noFrom:toNames(rel.no_damage_from), doubleTo:toNames(rel.double_damage_to), halfTo:toNames(rel.half_damage_to), noTo:toNames(rel.no_damage_to) }]; }));
  const chart=Object.fromEntries(entries); localStorage.setItem('typeChartV2', JSON.stringify(chart)); return chart;
}

function typeBadge(t){ const label=TYPE_LABEL_KO[t]||t; const color=TYPE_COLORS[t]||'#1a244d'; return `<span class="badge-type" style="background:${color}22;border-color:${color}66">${label}</span>`; }
function computeDefenseMultipliers(defTypes, chart){ const mult=Object.fromEntries(TYPE_KEYS.map(k=>[k,1])); for(const d of defTypes){ const rel=chart[d]; if(!rel) continue; for(const atk of rel.doubleFrom) mult[atk]*=2; for(const atk of rel.halfFrom)   mult[atk]*=0.5; for(const atk of rel.noFrom)     mult[atk]=0; } for(const k of Object.keys(mult)){ mult[k]=(mult[k]===0.25||mult[k]===0.5||mult[k]===1||mult[k]===2||mult[k]===4)?mult[k]:Number(mult[k].toFixed(2)); } return mult; }
function buildDefenseTable(defense){ const groups={'4':[], '2':[], '1':[], '0.5':[], '0.25':[], '0':[]}; for(const [atk,m] of Object.entries(defense)) groups[String(m)].push(atk); const order=['4','2','1','0.5','0.25','0']; const row=(mul,arr)=>{ const cells=(arr||[]).sort((a,b)=>(TYPE_LABEL_KO[a]||a).localeCompare(TYPE_LABEL_KO[b]||b)).map(typeBadge).join('')||'<span class="hint">없음</span>'; return `<tr class="row"><td style="width:120px">×${mul}</td><td>${cells}</td></tr>`; }; return `<table class="table"><thead><tr><th>배율</th><th>공격 타입</th></tr></thead><tbody>`+order.map(m=>row(m,groups[m])).join('')+`</tbody></table>`; }
function buildAttackTableFor(atkType, chart){ const rel=chart[atkType]||{doubleTo:[],halfTo:[],noTo:[]}; const set2=new Set(rel.doubleTo), set05=new Set(rel.halfTo), set0=new Set(rel.noTo); const x1=TYPE_KEYS.filter(t=>!set2.has(t)&&!set05.has(t)&&!set0.has(t)); const groups={ '2':Array.from(set2), '1':x1, '0.5':Array.from(set05), '0':Array.from(set0) }; const order=['2','1','0.5','0']; const row=(mul,arr)=>{ const cells=(arr||[]).sort((a,b)=>(TYPE_LABEL_KO[a]||a).localeCompare(TYPE_LABEL_KO[b]||b)).map(typeBadge).join('')||'<span class="hint">없음</span>'; return `<tr class="row"><td style="width:120px">×${mul}</td><td>${cells}</td></tr>`; }; return `<table class="table"><thead><tr><th>배율</th><th>상대 타입</th></tr></thead><tbody>`+order.map(m=>row(m,groups[m])).join('')+`</tbody></table>`; }
function attackCardsFor(types, chart){ return types.map(t=>{ const label=TYPE_LABEL_KO[t.type.name]||t.type.name; return `<div class="card" style="margin-top:14px"><div class="section-title">공격 상성 — 내 타입: ${label}</div>${buildAttackTableFor(t.type.name, chart)}</div>`; }).join(''); }
function computeDefenseSection(pokemon, chart){ const defense=computeDefenseMultipliers(pokemon.types.map(t=>t.type.name), chart); return `<div class="card" style="margin-top:14px"><div class="section-title">속성 상성 (방어 기준)</div>${buildDefenseTable(defense)}<div class="hint">설명: 공격 타입 대비 피해 배율입니다.</div></div>`; }
function computeAttackSection(pokemon, chart){ return attackCardsFor(pokemon.types, chart); }
function computeTypeSections(pokemon, chart){ return computeDefenseSection(pokemon, chart)+computeAttackSection(pokemon, chart); }

/* -------- 폼/바리에티 로딩 (메가/거다이맥스/지역 폼) -------- */
const REGION_KEYS=['alola','galar','hisui','paldea'];
const REGION_LABEL_KO={alola:'알로라', galar:'가라르', hisui:'히스이', paldea:'팔데아'};
function pickSprite(p){ return p?.sprites?.other?.['official-artwork']?.front_default || p?.sprites?.front_default || ''; }
async function loadForms(species, baseKo){ const result={ mega:[], gmax:[], regional:[] };
  for(const v of species.varieties||[]){ try{ const p=await fetchJson(v.pokemon.url); const name=p.name; const sprite=pickSprite(p); const types=p.types.map(t=>t.type.name);
      const rk=REGION_KEYS.find(k=>name.includes(k)); if(rk){ const label=`${baseKo} (${REGION_LABEL_KO[rk]}의 모습)`; result.regional.push({name,label,sprite,types}); }
      if(/mega/i.test(name)){ const label=`${baseKo} (메가진화${/mega.*x/i.test(name)?' X': /mega.*y/i.test(name)?' Y':''})`; result.mega.push({name,label,sprite,types}); }
      if(/gmax/i.test(name)){ const label=`${baseKo} (거다이맥스)`; result.gmax.push({name,label,sprite,types}); }
      for(const f of p.forms||[]){ try{ const form=await fetchJson(f.url); if(form.is_mega){ const label=`${baseKo} (메가진화${/mega-.*x$/i.test(form.name)?' X': /mega-.*y$/i.test(form.name)?' Y':''})`; result.mega.push({name:form.name,label,sprite,types}); }
          const fn=(form.form_name||'').toLowerCase(); if(form.is_battle_only && (fn==='gmax' || /gmax/i.test(form.name))){ const label=`${baseKo} (거다이맥스)`; result.gmax.push({name:form.name,label,sprite,types}); }
        }catch(e){ console.warn('form fetch fail', e); }
      }
    }catch(e){ console.warn('variety fetch fail', e); }
  }
  const dedup=(arr)=>Object.values(arr.reduce((acc,x)=>{acc[x.name]=x;return acc;},{}));
  result.mega=dedup(result.mega); result.gmax=dedup(result.gmax); result.regional=dedup(result.regional); return result;
}
function renderFormsSection(forms){ const any=(forms?.mega?.length||0)+(forms?.gmax?.length||0)+(forms?.regional?.length||0); if(!any) return '';
  const group=(title,items)=>{ if(!items||!items.length) return ''; const cards=items.map(it=>{ const types=(it.types||[]).map(t=>typeBadge(t)).join(''); return `<div class="mini-card">${it.sprite? `<img class="thumb" src="${it.sprite}" alt="${escapeHtml(it.label)}"/>`:''}<div class="label">${escapeHtml(it.label)}</div><div style="margin-top:6px">${types}</div></div>`; }).join(''); return `<div class="card" style="margin-top:14px"><div class="section-title">${title}</div><div class="forms-grid">${cards}</div></div>`; };
  return [ group('지역의 모습', forms.regional), group('메가진화', forms.mega), group('거다이맥스', forms.gmax) ].join('');
}

/* ---------- 렌더링 ---------- */
async function renderPokemon({ pokemon, species, evo, moves, koName, enName, forms }){
  const displayName = koName || (species.names||[]).find(n=>n.language?.name==='ko')?.name || enName || species.name;
  const id=pokemon.id; const sprite=pokemon.sprites?.other?.['official-artwork']?.front_default || pokemon.sprites?.front_default;
  const typesHtml = pokemon.types.map(t=>typeBadge(t.type.name)).join('');
  const moveList = moves.map(m=>`<div class="kv"><div>Lv.${m.level}</div><div>${escapeHtml(m.ko)} <span class="hint">(${escapeHtml(m.en)})</span></div></div>`).join('');
  const chart=await ensureTypeChart(); const typeSections=computeTypeSections(pokemon, chart);

  // 진화 표시 (edges or stages)
  let evoHtml='<span class="hint">진화 정보 없음</span>';
  if(Array.isArray(evo)&&evo.length){
    if(evo[0] && typeof evo[0]==='object' && 'from' in evo[0] && 'to' in evo[0]){
      evoHtml = evo.map(e=>{
        const fromNm=e.from.ko||e.from.en; const toNm=e.to.ko||e.to.en; const cond=formatEvoDetails(e.details);
        return `<div class="flex"><div class="pill"><span>#${e.from.id}</span><strong>${escapeHtml(fromNm)}</strong></div><span class="arrow">— ${escapeHtml(cond)} →</span><div class="pill"><span>#${e.to.id}</span><strong>${escapeHtml(toNm)}</strong></div></div>`;
      }).join('');
    }else if(evo[0] && 'id' in evo[0]){
      evoHtml = evo.map((s,i)=>{ const nm=s.ko||s.name; const mid=`<div class="pill"><span>#${s.id}</span><strong>${escapeHtml(nm)}</strong></div>`; return mid + (i<evo.length-1?'<span class="arrow">→</span>':''); }).join('');
    }
  }

  resultEl.innerHTML = `
    <div class="card">
      <div class="grid">
        <div class="col-4" style="text-align:center">
          ${sprite? `<img src="${sprite}" alt="${escapeHtml(displayName)}" class="sprite"/>`:''}
          <div style="margin-top:8px" class="flex"><span class="pill">#${id}</span>${typesHtml}</div>
        </div>
        <div class="col-8">
          <h2 style="margin:0 0 8px 0">${escapeHtml(displayName)} <span class="hint">(${escapeHtml(species.name)})</span></h2>
          <div class="grid" style="gap:8px">
            <div class="col-8">
              <div class="section-title">기본 정보</div>
              <div class="kv">
                <div>키/몸무게</div><div>${(pokemon.height/10).toFixed(1)} m / ${(pokemon.weight/10).toFixed(1)} kg</div>
                <div>능력</div><div>${abilities(pokemon.abilities)}</div>
                <div>기본 능력치</div><div>${statRows(pokemon.stats)}</div>
              </div>
            </div>
            <div class="col-4">
              <div class="section-title">알 정보</div>
              <div class="kv">
                <div>포획율</div><div>${species.capture_rate}</div>
                <div>기본친밀도</div><div>${species.base_happiness}</div>
                <div>성비</div><div>${genderRatio(species.gender_rate)}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    ${typeSections}

    ${renderFormsSection(forms)}

    <div class="card" style="margin-top:14px">
      <div class="section-title">진화 체인</div>
      <div class="evo">${evoHtml}</div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="section-title">레벨업 기술 (최신 버전 그룹 기준 최대 40개)</div>
      ${moveList || '<span class="hint">표시할 기술이 없습니다.</span>'}
    </div>`;
}

function genderRatio(g){ if(g===-1) return '무성'; const female=(g/8)*100; const male=100-female; return `♂ ${male.toFixed(0)}% / ♀ ${female.toFixed(0)}%`; }
function skeleton(){ return `<div class="card"><div class="flex"><div class="spinner"></div><div>조회 중… PokeAPI에서 데이터를 불러오는 중입니다.</div></div></div>`; }

// First-run
ensureSpeciesList().catch(e=>console.warn(e));
</script>
